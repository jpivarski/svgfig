#summary One-page summary of version 2
#labels Featured,Version2

== Why version 2? ==

In principle, SVGFig is supposed to be general and flexible enough to have a basic core that never changes, like TeX.  If so, then that core needs to be very well designed, and it's hard to assess an idea before it has been at least partially implemented.  I built at least four generations of pre-SVGFigs, tested them on actual analysis projects, and returned to the drawing board after each.  SVGFig 1.x was a great improvement, and represents a nearly-converged core.  Jim B. and I worked with this and brainstormed for a few months, deciding in the end to re-write the core one last time.  From SVGFig 2.0 onward, development should be upward: making interesting and highly-usable tools for specific types of plots, legends, figures, etc.  If you'd like to help define the plotting layer by contributing, [mailto:jpivarski@gmail.com send me an e-mail] and get a [https://www.google.com/accounts/NewAccount Google/GMail account] if you don't already have one (for SVN and wiki access).

== SVGFig 2.0.0alpha1 ==

To download, click here: [http://svgfig.googlecode.com/files/svgfig-2.0.0alpha1.tgz svgfig-2.0.0alpha1.tgz]

As the name implies, this is not a stable release, but something to show curious onlookers what's happening.  I'll assume that the reader is already familiar with [Introduction SVGFig 1.x].

As briefly as possible, here's what's new:
  * Python now "knows" a little about the SVG it's representing: how to transform it, the best order to read and present attributes from and to the user, and ultimately, it will be able to calculate intersections between paths and basic shapes.
  * Transformation functions now immediately change the objects they are applied to.  Different coordinate systems can be maintained in the same figure by explicitly delaying the evaluation of a subtree, like the "quote" function in Lisp.  This makes it easier to understand what SVGFig is doing, since coordinate systems are deliberately created by the user.
  * The old SVGFig maintained a distinction between transformable objects (with class names like Path) from plain SVG (created with code like SVG("path", ...)).  This distinction is no longer necessary: everything is an SVG object.  Some of these objects, like [ClassCurve Curve] (now subclasses of SVG), dynamically generate SVG data on output.
  * The adaptive-sampling algorithm used by Curve is now compiled for speed.  I have instructions on my [http://code.google.com/p/pyminuit/ !PyMinuit project page] for compiling on Windows, so it should still be cross-platform.  (That's what held this up before.)
  * Everything is pickleable, so you can save and restore the dynamic objects in addition to the static SVG.
  * Jim B.'s LaTeX-to-path module will be included in a later alpha version.  This is the most asked-for feature.  I have seen it working, so rest assured, it is definitely possible, even on Windows.  This 2.0.0alpha1 version has a very large LaTeX command name-to-Unicode conversion table, which is useful, but not as pretty as real LaTeX.
  * Includes a viewer that lets you pop open a persistent window and quickly render the SVG objects you're working on.  I find this to be essential for building up a plot and debugging.
  * Some annoying features in 1.x that generated a lot of output accidentally (try typing "for s in svg: print s" in 1.x sometime) have become explicit function calls.

== Tour guide ==

Have a copy of the code in front of you?  Good.  I'll point out the main features.

=== setup.py and the svgfig directory ===

SVGFig has been divided into several files for better organization, and there are now two compiled extension modules, so `setup.py` got a bit more complicated.  When invoked as
{{{
% python setup.py install
}}}
or
{{{
% python setup.py install --home=~
}}}
it attempts to compile `_curve.c` (which has no dependencies) and `_viewer.c` (which depends on `gtk+-2.0`, `gthread-2.0`, `cairo`, and `rsvg-2`).  If either of these fails, the installation proceeds, you will just have fewer features.  I highly recommend the viewer, but it's not essential.

=== interactive.py ===

Now that you have installed SVGFig, you will generally invoke it by executing
{{{
>>> from svgfig.interactive import *
}}}
on the command line.  This loads into the user's namespace only those functions which are useful for interactive plotting.  The others become accessible by their long names, like
{{{
>>> svgfig.defaults.xml_header = "<!-- change the default header -->"
}}}

=== svg.py ===

The SVG class is basically the same as it was in 1.x, with some tweaks.  (That's what I meant when I said that the core shows evidence of convergence.)  There's still a single SVG class which is differentiated into SVG element types by their tag name, e.g. SVG("line"...), SVG("circle"...), SVG("g"...).  The major new thing is that SVGFig knows the difference between a "line" and a "circle".  The first way you can see this is in the constructor:
{{{
>>> SVG("line", 0, 0, 10, 30)
<line x1=0 y1=0 x2=10 y2=30 stroke='black'>
>>> SVG("circle", 10, 30, 5, fill="yellow")
<circle cx=10 cy=30 r=5 stroke='black' fill='yellow'>
}}}

When the SVG tag is a "line", SVGFig looks in `defaults.py` for line's calling signature, which is
{{{
>>> defaults.signature_line
['x1', 'y1', 'x2', 'y2', 'stroke']
}}}
(and editable at run-time).  Only the first four arguments are required (see "defaults.require_line"), the rest have default values ("defaults.defaults_line").  In short, you construct SVG elements like you would a Python function from a reasonably well-designed library.  From the signature, SVGFig also knows which are the most important attributes and shows them in order in the string representation.  Other attributes, of which there might be many, are suppressed.
{{{
>>> SVG("line", 0, 0, 10, 30, stroke_width=5)
<line x1=0 y1=0 x2=10 y2=30 stroke='black' (1 other attribute)>
}}}

Since some attributes are now more important than others, accessing the signature attributes as though they were member data is feasible:
{{{
>>> SVG("line", 0, 0, 10, 30).x2
10
}}}
All attributes, children, sub-children, and attributes of sub-sub-sub-children, can still be accessed with the [http://code.google.com/p/svgfig/wiki/ClassSVG#Tree_indexing tree index] bracket notation introduced in version 1.

For some SVG elements, the children are more important than the attributes, so inline arguments are interpreted as children:
{{{
>>> print defaults.signature_g
None
>>> SVG("g", SVG("line", 0, 0, 10, 30))
<g (1 child)>
}}}

And then there are oddballs that need keyword arguments and children, so "calling" an SVG object like a function adds children inline:
{{{
>>> s = SVG("text", 50, 50)("what to say")
>>> s
<text 'what to say' x=50 y=50 stroke='none' fill='black'>
>>> print s.xml()
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">

<svg width="400" height="400" viewBox="0, 0, 100, 100" font-family="Helvetica, Arial, FreeSans, Sans, sans, sans-serif" style="font-size:4px; stroke-width:0.5pt; text-anchor:middle" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
    <text x="50" y="50" stroke="none" fill="black" >what to say</text>
</svg>
}}}

SVG elements now know how to transform themselves and calculate their bounding boxes; this functionality is also defined in `defaults.py`:
{{{
>>> s = SVG("line", 0, 0, 10, 30)
>>> s
<line x1=0 y1=0 x2=10 y2=30 stroke='black'>
>>> s.transform("y, x")
>>> s
<line x1=0.0 y1=0.0 x2=30.0 y2=10.0 stroke='black'>
>>> s.bbox()
<BBox xmin=0 xmax=30 ymin=0 ymax=10>
>>> defaults.transform_line
<function transform_line at 0xb7d1cd4c>
>>> defaults.bbox_line
<function bbox_line at 0xb7d1cd84>
}}}

The rest of the changes to the SVG class are minor conveniences:
  * The element type, list of children, and attributes are now called `tag`, `children`, and `attrib` to conform to the convention established by [http://effbot.org/zone/element-index.htm ElementTree].
  * Iteration over an SVG steps through its list of children, rather than recursively walking over the whole tree, which is more in line with its list-like member functions.  Recursive iteration over the whole tree is accessible through the "walk" function
  * Printing an SVG element just shows its string representation, as a normal Python user would expect.  To get a very useful print-out of the tree structure, use the "tree" function.
  * Now you can both save to and load from gzipped SVG, just end the fileName in "svg.gz" or "svgz".
  * Assuming you have the dependencies and it compiled, you can quickly view any SVG fragment with the "view" method, in addition to "inkview", "inkscape", and "firefox" to see it in different browsers.  The "view" method does not need to write any files.
  * Subclasses of SVG represent XML preprocessing instructions, comments, and CDATA.  These are inert in Python, but you don't lose this information by working on an image in SVGFig.
  * This can all be pickled.

== trans.py ==

_Coming soon!_
