#summary One-page summary of version 2
#labels Featured

== Why version 2? ==

In principle, SVGFig is supposed to be general and flexible enough to have a basic core that never changes, like TeX.  If so, then that core needs to be very well designed, and it's hard to assess an idea before it has been at least partially implemented.  I built at least four generations of pre-SVGFigs, tested them on actual analysis projects, and returned to the drawing board after each.  SVGFig 1.x was a great improvement, and represents a nearly-converged core.  Jim B. and I worked with this and brainstormed for a few months, deciding in the end to re-write the core one last time.  From SVGFig 2.0 onward, development should be upward: making interesting and highly-usable tools for specific types of plots, legends, figures, etc.  If you'd like to help define the plotting layer by contributing, [mailto:jpivarski@gmail.com send me an e-mail] and get a [https://www.google.com/accounts/NewAccount Google/GMail account] if you don't already have one (for SVN and wiki access).

== SVGFig 2.0.0alpha1 ==

To download, click here: [http://svgfig.googlecode.com/files/svgfig-2.0.0alpha1.tgz svgfig-2.0.0alpha1.tgz]

As the name implies, this is not a stable release, but something to show curious onlookers what's happening.  I'll assume that the reader is already familiar with [Introduction SVGFig 1.x].

As briefly as possible, here's what's new:
  * Python now "knows" a little about the SVG it's representing: how to transform it, the best order to read and present attributes from and to the user, and ultimately, it will be able to calculate intersections between paths and basic shapes.
  * Transformation functions now immediately change the objects they are applied to.  Different coordinate systems can be maintained in the same figure by explicitly delaying the evaluation of a subtree, like the "quote" function in Lisp.  This makes it easier to understand what SVGFig is doing, since coordinate systems are deliberately created by the user.
  * The old SVGFig maintained a distinction between transformable objects (with class names like Path) from plain SVG (created with code like SVG("path", ...)).  This distinction is no longer necessary: everything is an SVG object.  Some of these objects, like [ClassCurve Curve] (now subclasses of SVG), dynamically generate SVG data on output.
  * The adaptive-sampling algorithm used by Curve is now compiled for speed.  I have instructions on my [http://code.google.com/p/pyminuit/ !PyMinuit project page] for compiling on Windows, so it should still be cross-platform.  (That's what held this up before.)
  * Everything is pickleable, so you can save and restore the dynamic objects in addition to the static SVG.
  * Jim B.'s LaTeX-to-path module will be included in a later alpha version.  This is the most asked-for feature.  I have seen it working, so rest assured, it is definitely possible, even on Windows.  This 2.0.0alpha1 version has a very large LaTeX command name-to-Unicode conversion table, which is useful, but not as pretty as real LaTeX.
  * Includes a viewer that lets you pop open a persistent window and quickly render the SVG objects you're working on.  I find this to be essential for building up a plot and debugging.
  * Some annoying features in 1.x that generated a lot of output accidentally (try typing "for s in svg: print s" in 1.x sometime) have become explicit function calls.

== Tour guide ==

Have a copy of the code in front of you?  Good.  I'll point out the main features.

=== setup.py and the svgfig directory ===

SVGFig has been divided into several files for better organization, and there are now two compiled extension modules, so =setup.py= got a bit more complicated.  When invoked as
{{{
% python setup.py install
}}}
or
{{{
% python setup.py install --home=~
}}}
it attempts to compile =_curve.c= (which has no dependencies) and =_viewer.c= (which depends on =gtk+-2.0=, =gthread-2.0=, =cairo=, and =rsvg-2=).  If either of these fails, the installation proceeds, you will just have fewer features.  I highly recommend the viewer, but it's not essential.

=== interactive.py ===

Now that you have installed SVGFig, you will generally invoke it by executing
{{{
>>> from svgfig.interactive import *
}}}
on the command line.  This loads into the user's namespace only those functions which are useful for interactive plotting.  The others become accessible by their long names, like
{{{
>>> svgfig.defaults.xml_header = "<!-- change the default header -->"
}}}

=== svg.py ===

The SVG class is basically the same as it was in 1.x, with some tweaks.  (That's what I meant when I said that the core shows evidence of convergence.)  There's still a single SVG class which is differentiated into SVG element types by their tag name, e.g. SVG("line"...), SVG("circle"...), SVG("g"...).  The major new thing is that SVGFig knows the difference between a "line" and a "circle".  The first way you can see this is in the constructor:
{{{
>>> SVG("line", 0, 0, 10, 30)
<line x1=0 y1=0 x2=10 y2=30 stroke='black'>
>>> SVG("circle", 10, 30, 5, fill="yellow")
<circle cx=10 cy=30 r=5 stroke='black' fill='yellow'>
}}}

When the SVG tag is a "line", SVGFig looks in =defaults.py= for line's calling signature, which is
{{{
>>> defaults.signature_line
['x1', 'y1', 'x2', 'y2', 'stroke']
}}}
(and editable at run-time).  Only the first four arguments are required (see "defaults.require_line"), the rest have default values ("defaults.defaults_line").  In short, you construct SVG elements like you would a Python function from a reasonably well-designed library.  From the signature, SVGFig also knows which are the most important attributes and shows them in order in the string representation.  Other attributes, of which there might be many, are suppressed.
{{{
>>> SVG("line", 0, 0, 10, 30, stroke_width=5)
<line x1=0 y1=0 x2=10 y2=30 stroke='black' (1 other attribute)>
}}}


















