#summary Introduction to SVGFig
#labels Featured,Tutorial

SVGFig is a [http://www.python.org Python] extension module that defines two new classes, [ClassSVG SVG] (_svig_) and [ClassFig Fig] (_fig_).

[ClassSVG SVG] represents an image in [http://www.svg.org/ Scalable Vector Graphics] format, a markup language similar to HTML.  By making Scalable Vector Graphics commands accessible to the Python language, the [ClassSVG SVG] class broadens the user's capabilities in much the same way that dynamically-generated HTML did for webpages.  You can write programs that create images.

[ClassFig Fig] builds a mathematical figure by applying a coordinate transformation to graphics primatives.  Unlike the the strictly linear transformations in the Scalable Vector Graphics command-set, [ClassFig Fig] transformations can be any Python function.  Moreover, one often wants to transform only the mathematically-meaningful coordinates and not the widths of lines, lengths of tick marks, or radii of circular points, so [ClassFig Fig] allows you to make such a distinction.  [ClassFig Fig] transformations are composed by nesting, so you can make self-similar images by recursion.

= The SVG Class =

The [ClassSVG SVG] class is a document object model of the Scalable Vector Graphics image, meaning that the tree of objects normally represented in XML is represented instead in linked Python data structures.

=== Constructing SVG images ===

In XML-SVG, a rectangle can be expressed with the following command.
{{{
<rect x="10" y="10" width="60" height="60" />
}}}
To do the same in Python, load SVGFig and assign `s` to a new instance of the [ClassSVG SVG] class.  (See [HowToInstall "How to Install"] if the `import` command doesn't work.)
{{{
>>> from svgfig import *
>>> s = SVG("rect", x=10, y=10, width=60, height=60)
>>> print s.xml()
<rect y=10 width=60 height=60 x=10 />
}}}

In XML, elements can be nested, and the resulting tree structure is meaningful in Scalable Vector Graphics.  Graphics can be organized by grouping them in "g" elements, and many attributes can be inherited.  Let's create two rectangles and group them in a "g".
{{{
>>> s = SVG("rect", x=10, y=10, width=60, height=60, fill="red")
>>> s2 = SVG("rect", x=30, y=30, width=60, height=60, fill="blue")
>>> g = SVG("g", s, s2, fill_opacity="50%")
>>> g.save("tmp.svg")
}}}
Look at "tmp.svg" in a web browser or other Scalable Vector Graphics renderer.  You should see two overlapping, translucent squares.  In a graphics program like [http://www.inkscape.org/ Inkscape], the two squares should be grouped and moveable as a single object.

When we applied the `fill_opacity="50%"` attribute to the group, it was applied to all objects inside the group.  That can be overridden by giving one of the rectangles an explicit `fill_opacity`.  In the Scalable Vector Graphics specification, this attribute is actually called "fill-opacity", with a hyphen, not an underscore.  Python would interpret the hyphen as an attempt to subtract "opacity" from "fill", so we need to make some character substitutions.  An underscore (`_`) is mapped to a hyphen (`-`), and two underscores (`__`) are mapped to a colon (`:`).  Python uses the correct attribute names whenever they are quoted, e.g,
{{{
>>> g.attr
{'fill-opacity': '50%'}
}}}

=== Saving and viewing ===

The `save` method didn't simply call `xml` and write the output to disk.  If you look at "tmp.svg", you would see that the contents include a header and a top-level <svg /> object.
{{{
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">

<svg style="stroke:black; fill:none; stroke-width:0.5pt; stroke-linejoin:round; text-anchor:middle"
xmlns="http://www.w3.org/2000/svg" height="400px" width="400px" version="1.1"
xmlns:xlink="http://www.w3.org/1999/xlink" font-family="Helvetica,Arial,FreeSans,Sans,sans,sans-serif"
viewBox="0 0 100 100">

<g fill-opacity="50%">

<rect y="10" width="60" fill="red" x="10" height="60" />

<rect y="30" width="60" fill="blue" x="30" height="60" />

</g>

</svg>
}}}

The header is a necessary part of a Scalable Vector Graphics image, but it would be inconvenient to have to construct it every time you want to look at a graphics fragment.  The `save` method determines whether it is being called from a whole image or a fragment, and constructs the appropriate output.  (See [DefCanvas canvas] to make canvases explicitly.)

It was also unnecessary to specify a file name.  Without an argument, `save` overwrites "tmp.svg" in the current directory.  *Be careful that you don't keep anything important in "tmp.svg"!*

Building images by calling `save` and reloading in a web browser is reminiscent of writing web pages in HTML, but you can also call a viewer from Python, assuming that you have it installed on your system.  The [ClassSVG SVG] class has `firefox`, `inkview`, and `inkscape` methods, which write to a file just like `save`, but then immediately load it in a renderer.

To load Scalable Vector Graphics files from XML into Python, use the [Defload load] function.

=== Navigating SVG images in Python ===

Fairly often, you'll also want to explore the [ClassSVG SVG] object to see what's in it without looking at the full XML output.  Python's `print` command outputs the tree structure.
{{{
>>> print g
None                 <g (2 sub) fill-opacity='50%' />                                                
[0]                      <rect y=10 width=60 fill='red' x=10 height=60 />                            
[1]                      <rect y=30 width=60 fill='blue' x=30 height=60 />                           
}}}

The numbers on the left are tree indexes: you can reference any sub-element with a list of numbers and strings.  Our tree isn't interesting enough, so let's make a bigger one.
{{{
>>> g2 = SVG("g", SVG("g", SVG("g", g)))
>>> print g2
None                 <g (1 sub) />                                                                   
[0]                      <g (1 sub) />                                                               
[0, 0]                       <g (1 sub) />                                                           
[0, 0, 0]                        <g (2 sub) fill-opacity='50%' />                                    
[0, 0, 0, 0]                         <rect y=10 width=60 fill='red' x=10 height=60 />                
[0, 0, 0, 1]                         <rect y=30 width=60 fill='blue' x=30 height=60 />               
}}}
The blue square is the second sub-element (1) of the first sub-element (0) of the first sub-element (0) of the first sub-element (0) of `g2`.  We can reference it with
{{{
>>> g2[0, 0, 0, 1]
<rect y=30 width=60 fill='blue' x=30 height=60 />
}}}

This kind of indexing replaces and deletes elements, too.
{{{
>>> g2[0, 0, 0, 1] = SVG("circle", cx=60, cy=60, r=30, fill="blue")
>>> print g2
None                 <g (1 sub) />                                                                   
[0]                      <g (1 sub) />                                                               
[0, 0]                       <g (1 sub) />                                                           
[0, 0, 0]                        <g (2 sub) fill-opacity='50%' />                                    
[0, 0, 0, 0]                         <rect y=10 width=60 fill='red' x=10 height=60 />                
[0, 0, 0, 1]                         <circle cy=60 cx=60 r=30 fill='blue' />                         
>>> g2.inkview()   # to look at it
>>> 
>>> del g2[0, 0, 0, 0]
>>> print g2
None                 <g (1 sub) />                                                                   
[0]                      <g (1 sub) />                                                               
[0, 0]                       <g (1 sub) />                                                           
[0, 0, 0]                        <g (1 sub) fill-opacity='50%' />                                    
[0, 0, 0, 0]                         <circle cy=60 cx=60 r=30 fill='blue' />                         
>>> g2.inkview()
}}}

A tree index that ends in a string references the attribute (no underscore/hyphen substitution).
{{{
>>> g2[0, 0, 0, "fill-opacity"]
'50%'
}}}

Just about everything in Python can be used in a `for` loop, and [ClassSVG SVG] is no exception.  Iterating over an [ClassSVG SVG] object performs a depth-first walk over all the sub-elements and attributes, returning (tree index, element) pairs.  The only thing you don't step over in the loop is the top-level object (which has no tree index).
{{{
>>> for ti, s in g2:
...     print ti, repr(s)
... 
(0,) <g (1 sub) />
(0, 0) <g (1 sub) />
(0, 0, 0) <g (1 sub) fill-opacity='50%' />
(0, 0, 0, 0) <circle cy=60 cx=60 r=30 fill='blue' />
(0, 0, 0, 0, 'cy') 60
(0, 0, 0, 0, 'cx') 60
(0, 0, 0, 0, 'r') 30
(0, 0, 0, 0, 'fill') 'blue'
(0, 0, 0, 'fill-opacity') '50%'
}}}

=== More documentation ===

So now that you know how to build a Scalable Vector Graphic image in principle, what are the commands?
  * [http://www.w3.org/Graphics/SVG/ The W3C specification] is the definitive reference, but it can sometimes be hard to understand.
  * I often draw what I want to learn in [http://www.inkscape.org Inkscape] and save as "Plain SVG," then look at the output.
  * [http://www.w3schools.com/svg/default.asp W3 Schools] has a good tutorial.

If you need to know more about the Python language, see the [http://www.python.org/ official website].  If you just need to look something up, see [http://rgruet.free.fr/ Richard Gruet's quick reference pages].

Of course, all the SVGFig documentation is available [Reference on this site] and through Python's `help` command.

= The Fig Class =